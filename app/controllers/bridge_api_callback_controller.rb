class BridgeApiCallbackController < ApplicationController
  protect_from_forgery with: :null_session # avoids CSRF issues on server-to-server interactions

  EXPECTED_SIGNATURE = ENV['BRIDGEAPI_EXPECTED_SIGNATURE']
  EXPECTED_IPS = %w[63.32.31.5 52.215.247.62 34.249.92.209].freeze

  # item refresh event is generated by a banking account has been refreshed
  def callback_handler
    validate_request_authenticity! unless ENV['IGNORE_BRIDGEAPI_AUTHENTICITY']

    case params['type']
    when 'item.created'
      puts 'Item created'
      puts params
      handle_item_created(params['content'])
      # not handled for now
    when 'item.account.created'
      handle_account_created(params['content'])
    when 'item.account.updated'
      handle_account_updated(params)
    when 'item.refreshed'
      puts 'Item refreshed!'
      puts params
    when 'TEST_EVENT'
      puts 'Received a test event'
      puts params
    else
      puts "Received #{params['type']} event type, unknown, raising a 400"
      render :item_refresh, status: :bad_request
    end
  end

  def manual_refresh
    puts 'Received manual refresh'
    account = BridgeApiAccount.find(params['account_id'])
    account.refresh_transactions(params['timestamp'])
  end

  private

  def handle_item_created(content)
    user = User.where(bridgeapi_uuid: content['user_uuid']).first
    raise "Unable to find a user with uuid #{content['user_uuid']}" unless user

    user.bridge_api_items.create(item_id: content['item_id'])
  end

  def handle_account_updated(params)
    puts 'Received account updated event'
    puts params
    account = BridgeApiAccount.find(params['content']['account_id'])
    account.refresh_transactions(params['timestamp'])
  end

  def handle_account_created(content)
    client = BridgeApi::Dependencies.resolve(:client)
    puts 'Received account created event'
    item = BridgeApiItem.where(item_id: content['item_id']).first
    raise "Unknown item #{content['item_id']}" unless item

    account_info = client.account(content['account_id'], token: item.user.valid_access_token)
    account = item.bridge_api_accounts.create(id: content['account_id'], last_successful_fetch: Time.at(0), name: account_info['name'])
    raise "Failed to create a new account for #{item.user.username}" unless account.save

    puts "Saved a new account for user #{item.user.username}"
  end

  # this method ensure the authenticity of request from bridgeapi
  def validate_request_authenticity!
    ips = request.headers['HTTP_X_FORWARDED_FOR']
    render :item_refresh, status: :unauthorized unless ips
    render :item_refresh, status: :unauthorized if ips.split(',').none? { |i| EXPECTED_IPS.include?(i.strip) }

    signatures = request.headers['HTTP_BRIDGEAPI_SIGNATURE']
    render :item_refresh, status: :unauthorized unless signatures
    render :item_refresh, status: :unauthorized if signatures.split(',').none? { |s| s == EXPECTED_SIGNATURE }
  end
end
